# 📘 **CONDUCTOR.md**

## Distributed Request/Notification Pipeline for Cirreum Applications

Conductor is the core runtime engine that powers Cirreum’s handler-based execution model.  
It provides:

- A fast, allocation-minimal dispatcher
- Automatic handler discovery from assemblies
- A deterministic intercept pipeline (validation → authorization → performance → caching)
- A flexible publisher for request-side notifications
- A consistent DI-based lifetime model
- A clean API surface for registering and composing behavior

Conductor is designed to work in both low-level scenarios (raw control) and high-level application setups (via `AddDomainServices`).

---

## 🧩 Table of Contents

1. What Conductor Is  
2. Key Concepts  
3. Registration Modes  
4. Settings & Configuration  
5. DI Lifetime Model  
6. Intercept Pipeline  
7. Handler Discovery  
8. Notification Publishing  
9. Custom Intercepts  
10. Error Handling Model  
11. Unit Testing Guarantees  
12. Appendix: DI Contract Table  

---

## 🎯 What Conductor Is

Conductor is a highly optimized, mediator-style execution engine designed around:

- CQRS patterns  
- Railway-oriented programming (`Result<T>`)  
- Deterministic pre- and post-handler intercepts  
- Runtime-agnostic behavior (Server, Functions, WASM)

A Conductor “request” flows through:

```text
Validate → Authorize → Custom Intercepts → Handler Execution → Publish Notifications → Caching
```

All steps are opt-in and configurable.

---

## 📐 Key Concepts

| Concept | Description |
|--------|-------------|
| **Dispatcher** | The central executor for requests & queries. |
| **Publisher** | Publishes notifications generated by request handlers. |
| **Intercepts** | Middleware-like components that wrap handler execution. |
| **Handlers** | Business logic units (Requests, Queries, Commands). |
| **Settings** | Publisher strategy, caching options, etc. |
| **ConductorBuilder** | Registers handlers & intercepts (raw mode). |
| **ConductorOptionsBuilder** | Configures lifetime, settings, domain intercepts. |

---

## 🛠️ Registration Modes

Conductor intentionally supports **three** layers of registration.

---

### 1. Raw Registration (`AddConductor`)

Use this when you want full manual control.

```csharp
services.AddConductor(
    builder => {
        builder.RegisterFromAssemblies(typeof(Startup).Assembly)
               .AddOpenIntercept(typeof(MyAudit<,>));
    },
    options => {
        options.WithLifeTime(ServiceLifetime.Transient);
        options.WithSetting(customSettings);
    });
```

**Raw mode characteristics**  

- You manually build the intercept pipeline  
- You manually register all default intercepts  
- No automatic pipeline is applied  
- `AddCustomIntercepts` is **not allowed** here  
- Best for advanced frameworks / library scenarios  

---

### 2. Application Mode (`AddDomainServices`) — Recommended

This gives you the opinionated, safe defaults:

```csharp
services.AddDomainServices(Configuration);
```

Automatically includes:

- Handler assembly scanning  
- Full default pipeline  
- Settings bound from configuration  
- Dispatcher lifetime (default: Transient)  
- Custom-intercept insertion point  

Extend the pipeline safely:

```csharp
services.AddDomainServices(Configuration, options => {
    options.AddCustomIntercepts(builder =>
        builder.AddOpenIntercept(typeof(DomainAudit<,>)));
});
```

---

### 3. DomainBuilder Integration

Highest-level integration for apps that should not touch Conductor internals directly:

```csharp
builder.ConfigureConductor(opts => {
    opts.WithLifeTime(ServiceLifetime.Scoped);
    opts.AddCustomIntercepts(b => b.AddOpenIntercept(typeof(DomainAudit<,>)));
});
```

This is ideal for application developers. Framework/library code wires Conductor; applications configure via a simplified surface.

---

## ⚙️ Settings & Configuration

Conductor settings control runtime behavior:

| Setting | Description |
|---------|-------------|
| `PublisherStrategy` | Determines how notification handlers are invoked. |
| `Cache.Provider` | InMemory, Distributed, None. |
| `Cache.DefaultExpiration` | Global TTL for cached queries. |

### From configuration

```csharp
services.AddConductor(Configuration);
```

### Or manually

```csharp
services.AddConductor(
    _ => { },
    opts => opts.WithSetting(mySettings));
```

Settings are ultimately materialized into a singleton `ConductorSettings` instance and also consumed during registration (e.g., cache setup).

---

## 🧬 DI Lifetime Model

Lifetimes are part of Conductor’s public contract and are enforced by tests.

### Default Lifetimes

| Component | Lifetime | Notes |
|----------|----------|-------|
| **Dispatcher** | Transient | Overrideable via options. |
| **Publisher** | Mirrors Dispatcher | Enforced by tests. |
| **Handlers** | Transient | Always. |
| **Intercepts** | Same as Dispatcher | Keeps pipeline behavior consistent. |
| **Settings** | Singleton | Immutable runtime configuration. |
| **Facades** | Same as Dispatcher | `IDispatcher`, `IPublisher`, `IConductor`. |

### Scope validation

When `ServiceProviderOptions.ValidateScopes = true`:

- Resolving a **scoped** dispatcher from the **root** container throws.  
- Having a **singleton** that depends on a **scoped** dispatcher throws.

These behaviors are covered by tests such as:

- `ScopedDispatcher_ResolvedFromRoot_ThrowsOnValidateScopes`  
- `ScopedDispatcher_UsedFromSingleton_ThrowsOnValidateScopes`

---

## 🧵 Intercept Pipeline

### Raw Mode

In raw `AddConductor`, you fully control the intercept pipeline:

```csharp
services.AddConductor(
    builder => {
        builder.RegisterFromAssemblies(typeof(Startup).Assembly)
               .AddOpenIntercept(typeof(Validation<,>))
               .AddOpenIntercept(typeof(Authorization<,>))
               .AddOpenIntercept(typeof(HandlerPerformance<,>))
               .AddOpenIntercept(typeof(QueryCaching<,>));
    },
    options => {
        options.WithSetting(customSettings);
    });
```

The order is exactly the order you register.

### Domain Mode (Deterministic)

When using `AddDomainServices`, Conductor applies a standard domain pipeline:

```text
Validation
→ Authorization
→ (Custom Intercepts)
→ HandlerPerformance
→ QueryCaching
```

This is enforced by tests:

- `DomainPipeline_Intercepts_AreRegisteredInExpectedOrder`  
- `Intercepts_AreRegisteredInExpectedOrder_ForRawAddConductor`

---

## 🧲 Handler Discovery

Conductor automatically discovers handlers from assemblies via:

```csharp
builder.RegisterFromAssemblies(assemblies);
```

This wiring registers:

- `IRequestHandler<TRequest, TResponse>` implementations  
- `INotificationHandler<TNotification>` implementations  

All handlers are registered as **Transient** to avoid stale state and ensure request isolation.

This is enforced by tests such as:

- `RequestHandlers_AreAlwaysTransient`

---

## 📡 Notification Publishing

The `Publisher` is responsible for notifying `INotificationHandler<TNotification>` implementations.  
Its behavior is controlled by `PublisherStrategy`:

```csharp
public enum PublisherStrategy {
    /// <summary>
    /// Handlers are invoked one at a time, in order. 
    /// If one fails, subsequent handlers still execute.
    /// </summary>
    Sequential,

    /// <summary>
    /// Handlers are invoked one at a time, in order. 
    /// If one fails, subsequent handlers will not be executed.
    /// </summary>
    FailFast,

    /// <summary>
    /// All handlers are invoked simultaneously.
    /// Waits for all to complete before returning.
    /// </summary>
    Parallel,

    /// <summary>
    /// Handlers are invoked asynchronously without waiting for completion.
    /// If one fails, subsequent handlers still execute.
    /// Returns immediately after queueing.
    /// </summary>
    FireAndForget
}
```

### Sequential

- Handlers execute **one at a time**, in registration order.  
- If a handler throws, the exception is captured according to the error model.  
- Remaining handlers **still run**.

### FailFast

- Handlers execute **one at a time**, in registration order.  
- If a handler throws, publishing **stops immediately**.  
- Remaining handlers are **not invoked**.

### Parallel

- Handlers execute **concurrently**.  
- Publishing waits for **all** handlers to complete.  
- Exceptions are aggregated/handled according to the error model.

### FireAndForget

- Handlers are queued to run asynchronously.  
- Publishing **returns immediately** and does not await completion.  
- Best for non-critical notifications where latency is more important than completion guarantees.

Your unit tests validate that different `ConductorSettings` presets correctly map to these strategies and that the registration pipeline wires `Publisher` with the configured strategy.

---

## 🔌 Custom Intercepts

Custom intercepts allow you to extend the pipeline with domain-specific concerns  
(e.g., tenant isolation, auditing, extra validation).

## Custom Mode

In raw `AddConductor`, you control the pipeline directly using `ConductorBuilder`:

```csharp
services.AddConductor(
    builder => {
        builder.RegisterFromAssemblies(typeof(Startup).Assembly)
               .AddOpenIntercept(typeof(MyCustomIntercept<,>));
    },
    options => {
        options.WithSetting(customSettings);
    });
```

> ❗ `ConductorOptionsBuilder.AddCustomIntercepts(...)` is **not allowed** in this mode and will throw.  
> Use `builder.AddOpenIntercept(...)` instead.

## Domain Mode

In `AddDomainServices`, you get a safe extension point between Authorization and Performance:

```csharp
services.AddDomainServices(Configuration, options => {
    options.AddCustomIntercepts(builder => {
        builder.AddOpenIntercept(typeof(DomainAudit<,>));
        builder.AddOpenIntercept(typeof(TenantIsolation<,>));
    });
});
```

Here:

- Validation and Authorization are wired by the framework.  
- Your custom intercepts are inserted after Authorization.  
- Performance and caching intercepts still run afterward.

---

## 🛑 Error Handling Model

Conductor’s dispatcher and publisher follow a consistent error model:

### Non-Fatal Exceptions

- Typically domain or validation failures.  
- Captured and converted into `Result<T>.Failure`.  
- Request code can pattern-match on the failure without throwing.

### Fatal Exceptions

- Out-of-memory, thread-abort, and other catastrophic errors.  
- Re-thrown and **bubble out** of the pipeline.  
- Not converted into `Result<T>` failures.

### Cancellation

- If the handler honors `CancellationToken`, cancellation flows naturally.  
- The dispatcher ensures `OperationCanceledException` is preserved.  

These behaviors are tested in:

- `DispatchAsync_FatalException_IsNotConvertedToResultFailure`  
- `DispatchAsync_PropagatesCancellation_WhenHandlerHonorsToken`  
- `DispatchAsync_NonFatalException_IsConvertedToResultFailure`

---

## 🧪 Unit Testing Guarantees

Conductor has a comprehensive test suite around:

### Lifetimes

- Default dispatcher is Transient.  
- Dispatcher lifetime mirrors into Publisher and facades.  
- `AddDomainServices` can override lifetime and tests confirm the override.  
- Misconfigured scopes (scoped-used-from-singleton, root-resolved scoped) throw.

### Pipelines

- Raw pipeline: order matches registration.  
- Domain pipeline: Validation → Authorization → Custom → Performance → Caching.  
- `AddConductor` cannot be called twice on the same `IServiceCollection`.

### Settings

- Settings passed via `WithSetting` are honored.  
- Cache configuration flows to the cache layer.  

These tests collectively ensure that Conductor’s DI and pipeline contracts cannot regress silently.

---

## 📋 Appendix: DI Contract Table

| Service | Lifetime | Notes |
|--------|----------|-------|
| `Dispatcher` | Configurable (default: Transient) | Core executor. |
| `Publisher` | Mirrors Dispatcher | Uses configured `PublisherStrategy`. |
| `IDispatcher` | Matches Dispatcher | Facade over `Dispatcher`. |
| `IPublisher` | Matches Dispatcher | Facade over `Publisher`. |
| `IConductor` | Matches Dispatcher | Facade over `Dispatcher`. |
| `IRequestHandler<,>` | Transient | Business logic handlers. |
| `INotificationHandler<>` | Transient | Notification handlers. |
| `IIntercept<,>` | Matches Dispatcher | Pipeline components. |
| `ConductorSettings` | Singleton | Immutable configuration snapshot. |

---

**End of CONDUCTOR.md**  
